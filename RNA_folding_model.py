"""This scripts simulates the accumulation of Dobzhansky-Muller incompatibilitiesby allowing two RNA sequences to diverge in a holey landscape."""__author__ = 'Ata Kalirad'import osimport picklefrom copy import *from itertools import *import numpy as npimport pandas as pdimport RNA as RNARNA_nucl = ['A', 'C', 'G', 'U']RNA_folding_dict = {} #stores the seconary structures of RNA sequences during divergenceclass RNASeq(object):    def __init__(self, seq):        """Initialize RNASeq object.        Parameters        ----------        seq : string            A RNA sequence.        """        self.seq = seq        self.L = len(seq)        if seq in RNA_folding_dict:            self.struct, self.mfe = RNA_folding_dict[seq]        else:            mfe_struct = RNA.fold(seq)            self.struct, self.mfe = mfe_struct            RNA_folding_dict[seq] = mfe_struct    def update_struct(self):        """Calculate MFE and secondary structure of self.seq.        """        if self.seq in RNA_folding_dict:            self.struct, self.mfe = RNA_folding_dict[self.seq]        else:            mfe_struct = RNA.fold(self.seq)            self.struct, self.mfe = mfe_struct            RNA_folding_dict[self.seq] = mfe_struct    @staticmethod    def mutate(seq):        """Mutate a RNA sequecnnce        Parameters        ----------        seq : string            A RNA sequence.        Returns        -------        string            The input RNA sequence mutated at a single locus.        """        locus = np.random.randint(0, len(seq))        alleles = [i for i in RNA_nucl if i != seq[locus]]        np.random.shuffle(alleles)        return seq[:locus] + alleles[0] + seq[locus + 1:]    def diverge(self, other):        """mutate self while exluding sites that previously mutated.        Parameters        ----------        other : RNASeq            The RNA sequence self is diverging from.        Raises        ------        ValueError,            Two sequences cannot be diverged on every site.        """        dist_t1 = self.hamdist(other)        if dist_t1 == self.L:            raise ValueError, 'Two sequences cannot be diverged on every site.'        dist_t2 = 0        while dist_t2 != dist_t1 + 1:            mut = RNASeq.mutate(self.seq)            dist_t2 = RNASeq(mut).hamdist(other)        self.seq = mut        self.update_struct()    def hamdist(self, other):        """Calculate the Hamming distance between two sequence.        Parameters        ----------        str1 : string            The first sequence.        str2 : TYPE            The second sequence.        Returns        -------        diffs : int            The Hamming distance between the two sequences.        """        assert type(self) is type(other)        diffs = 0        for ch1, ch2 in zip(self.seq, other.seq):            if ch1 != ch2:                diffs += 1        return diffs    @staticmethod    def site_directed_mutate(seq, locus, allele):        """Mutate the sequnce at the given locus.        Parameters        ----------        seq : str            A string of letters consisting of C and G.        locus : int or list            The site(s) of mutation.        allele : str or list            The new allele(s).        Returns        -------        str        """        if type(locus) == list:            assert len(locus) == len(allele)            for i, j in zip(locus, allele):                seq = seq[:i] + j + seq[i + 1:]            return seq        else:            return seq[:locus] + allele + seq[locus + 1:]    @staticmethod    def get_introgression(seq1, seq2, num_introg):        """Introgress numcleotides from seq2 into seq1        Parameters        ----------        seq1 : str        seq2 : str        num_introg : int            number of introgressions (up to 4).        Returns        -------        list            A list of introgressions.        """        assert len(seq1) == len(seq2)        assert 1 <= num_introg <= 4        indices = []        temp = RNASeq.get_diverged_alleles(seq1, seq2)        if temp != 0:            indices = temp[2]        introgress = []        if num_introg == 1:            for i in range(len(seq1)):                if seq1[i] != seq2[i]:                    introgress.append(seq1[:i] + seq2[i] + seq1[i + 1:])        else:            indices_introg = list(combinations(indices, num_introg))            for i in indices_introg:                if num_introg == 2:                    introgress.append(seq1[:i[0]] + seq2[i[0]] + seq1[i[                        0] + 1:i[1]] + seq2[i[1]] + seq1[i[1] + 1:])                elif num_introg == 3:                    introgress.append(seq1[:i[0]] + seq2[i[0]] + seq1[i[                        0] + 1:i[1]] + seq2[i[1]] + seq1[i[1] + 1:i[2]] + seq2[                            i[2]] + seq1[i[2] + 1:])                elif num_introg == 4:                    introgress.append(seq1[:i[0]] + seq2[i[0]] + seq1[i[                        0] + 1:i[1]] + seq2[i[1]] + seq1[i[1] + 1:i[2]] + seq2[                            i[2]] + seq1[i[2] + 1:i[3]] + seq2[i[3]] + seq1[i[                                3] + 1:])        return introgress    @staticmethod    def get_diverged_alleles(seq1, seq2, index=True):        """Find diverged loci between two sequences.        Parameters        ----------        seq1 : string            The first sequence.        seq2 : string            The second sequence.        index : bool, optional            An index of diverged loci.        Returns        -------        seq1_alleles: list            A list of diverged alleles on seq1.        seq2_alleles: list            A list of diverged alleles on seq2.        """        assert len(seq1) == len(seq2)        seq1_alleles = []        seq2_alleles = []        indices = []        for i in range(len(seq1)):            if seq1[i] != 'X' and seq2[i] != 'X':                if seq1[i] != seq2[i]:                    seq1_alleles.append(seq1[i])                    seq2_alleles.append(seq2[i])                    indices.append(i)        if len(indices) != 0:            if index:                return seq1_alleles, seq2_alleles, indices            else:                return seq1_alleles, seq2_alleles        else:            return 0    @staticmethod    def get_intermediate_backgrounds(seq1, seq2, ref_seq, alpha, lim=100):        """Generate intermediate genetic backgrounds between two sequences.        Parameters        ----------        seq1 : str            A string of four letters, A, C, G, and U.        seq2 : str            A string of four letters, A, C, G, and U.        Returns        -------        backgrounds : list            A list of intermediate genetic backgrounds.        """        assert len(seq1) == len(seq2)        temp = RNASeq.get_diverged_alleles(seq1, seq2)        int_seqs = []        if temp != 0:            seq1_a, seq2_a, loci = temp            if len(loci) <= 5:                loci_lim = len(loci)            else:                loci_lim = 5            for i in np.arange(1, loci_lim - 1, 1):                combs = list(combinations(loci, i))                for j in combs:                    temp = deepcopy(seq1)                    for l in j:                        temp = temp[:l] + seq2[l] + temp[l + 1:]                    temp_g = RNASeq(temp)                    bp = RNA.bp_distance(ref_seq.struct, temp_g.struct)                    if bp <= alpha:                        int_seqs.append(temp)                    if len(int_seqs) >= lim:                        break        return int_seqs    @staticmethod    def recombine(seq1, seq2):        """Recombine two seqs.        Parameters        ----------        seq1 : str            A string of four letters, A, C, G, and U.        seq2 : str            A string of four letters, A, C, G, and U.        Returns        -------        recs : list            A ''list'' recombinants.        Notes        -----        This method generates all the recombinant with one cross-over event.        For a sequence of size N, there would be 2*(N-1) recombinants.        """        assert len(seq1) == len(seq2)        recs = []        for i in np.arange(1, len(seq1), 1):            recs.append(seq1[:i] + seq2[i:])            recs.append(seq2[:i] + seq1[i:])        return recs    def get_bp_distance(self, other):        """Get base-pair distance between two genotype objects.        Parameters        ----------        other : Genotype object        """        assert type(self) == type(other)        return RNA.bp_distance(self.struct, other.struct)class Evolution(object):    def __init__(self, seq, alpha=12):        """Initialize Evolution object.        Parameters        ----------        seq : string            The strating sequence which serves as the ref_seq.        alpha : int, optional            Alpha parameter used in the fitness function.        """        self.ref_seq = RNASeq(seq)        self.ancestor = RNASeq(seq)        self.alpha = alpha        self.mutated_loci = 'null'        self.mutated_allele = 'null'        self.mutated_line = 'null'    def init_history(self):        """Intialize the lists necessary for keeping track of the simulation.        """        self.divergence = []        self.mutations = []        self.linA = []        self.linB = []        self.linA_mfe = []        self.linB_mfe = []        self.linA_bp = []        self.linB_bp = []        self.avg_mfe = []        self.p1 = []        self.p2 = []        self.p3 = []        self.CDMI_1st = []        self.CDMI_2nd = []        self.CDMI_3rd = []        self.SDMI = []        self.CDMI = []    def add_to_history(self, SDMI_test=True):        """Update history lists.        """        self.linA.append(self.lineageA)        self.linB.append(self.lineageB)        self.linA_mfe.append(self.lineageA.mfe)        self.linB_mfe.append(self.lineageB.mfe)        self.linA_bp.append(self.lineageA.get_bp_distance(self.ref_seq))        self.linB_bp.append(self.lineageB.get_bp_distance(self.ref_seq))        self.avg_mfe.append(np.mean((self.lineageA.mfe, self.lineageB.mfe)))        self.divergence.append(self.lineageA.hamdist(self.lineageB))        self.mutations.append((self.mutated_line, self.mutated_loci, self.mutated_allele))        temp = self.get_DMIs(SDMI_test= SDMI_test)        self.SDMI.append(temp['SDMI'])        self.CDMI.append(temp['CDMI'])        self.p1.append(temp['p1'])        self.p2.append(temp['p2'])        self.p3.append(temp['p3'])        self.CDMI_1st.append(temp['CDMI_1st'])        self.CDMI_2nd.append(temp['CDMI_2nd'])        self.CDMI_3rd.append(temp['CDMI_3rd'])        self.SDMI_past_gen = temp['SDMI']    @property    def stats(self):        """Generate a dictionary of history.        Returns        -------        dict        """        stats = {}        stats['ancestor'] = self.ancestor.seq        stats['ref_seq'] = self.ref_seq.seq        stats['divergence'] = self.divergence        stats['seqs_linA'] = [i.seq for i in self.linA]        stats['seqs_linB'] = [i.seq for i in self.linB]        stats['mfe_A'] = self.linA_mfe        stats['mfe_B'] = self.linB_mfe        stats['bp_A'] = self.linA_bp        stats['bp_B'] = self.linB_bp        stats['mfe_avg'] = self.avg_mfe        stats['p1'] = self.p1        stats['p2'] = self.p2        stats['p3'] = self.p3        stats['CDMI_1st'] = self.CDMI_1st        stats['CDMI_2nd'] = self.CDMI_2nd        stats['CDMI_3rd'] = self.CDMI_3rd        stats['CDMI_1st_count'] = [len(i) for i in self.CDMI_1st]        stats['CDMI_2nd_count'] = [len(i) for i in self.CDMI_2nd]        stats['CDMI_3rd_count'] = [len(i) for i in self.CDMI_3rd]        stats['SDMI'] = self.SDMI        stats['SDMI_count'] = [len(i) for i in self.SDMI]        stats['CDMI'] = self.CDMI        stats['CDMI_count'] = [len(i) for i in self.CDMI]        stats['CDMI_total'] = np.array([len(i) for i in self.CDMI_1st]) + np.array([len(i) for i in self.CDMI_2nd]) + np.array([len(i) for i in self.CDMI_3rd])        temp = self.get_RI()        stats['RI'] = temp['RI']        return stats    def save_stats(self, directory, file_ID):        """Pickle stats dictionary.        Parameters        ----------        directory : dictionary            The stat dictionary.        file_ID : int            An integer added to the file name to avoid overwritting.        Returns        -------        name : pickle            Pickled stat dictionary.        """        if not os.path.exists(directory):            os.makedirs(directory)        file = open(directory + "/stats_" + str(file_ID), 'w')        pickle.dump(self.stats, file)        file.close()    @property    def phenotypic_change(self):        """Measure the change in base pair distance between two evolving lines.        Returns        -------        bp : list            A list of base pair distance between two evolving lines as they diverge.        """        bp_A = []        for i in range(len(self.linA)):            bp_A.append(self.linA[i].get_bp_distance(self.ref_seq))        bp_B = []        for i in range(len(self.linB)):            bp_A.append(self.linB[i].get_bp_distance(self.ref_seq))        return map(np.mean, zip(*[bp_A, bp_B]))    def get_fitness(self, mutated):        """Calculate the fitness of a given seqeunce.        Parameters        ----------        mutated : Genotype object            A Genotype whose fitness is to be determined.        Returns        -------        name : int            Returns 1 if base pair distance between the given genotype compared to            the ref_seq is less or equal to the alpha, otherwise returns 0.        """        assert type(self.ref_seq) == type(mutated)        if mutated.struct.count('(') <= self.alpha:            return 0        else:            bp = RNA.bp_distance(self.ref_seq.struct, mutated.struct)            if bp <= self.alpha:                return 1.            else:                return 0    def test_reciprocity(self, seqA, seqB, pos_2nd):        """Test if the a putative simple DMI is deleterious in both lineages.        Parameters        ----------        pos_2nd : int            The second locus involved in a putative simple DMI.        Returns        -------        w_reciprocal : int            Returns 1 if the DMI is deleterious in the other lineage.        """        reciprocal_seq = RNASeq.site_directed_mutate(seqB, pos_2nd, seqA[pos_2nd])        w_reciprocal = self.get_fitness(RNASeq(reciprocal_seq))        if w_reciprocal:            return 0        else:            return 1.    def get_DMIs(self, SDMI_test=True):        """Find the incompatibilities between the two diverging sequences, lineageA and lineageB.        Returns        -------        dict            A dictionary containg number of simple DMIs ("SDMI"), deleterious single introgressions that couldn't be rescued ("CDMI"),            deleterious single introgressions ("CDMI_1st"), deleterious double introgressions ("CDMI_2nd"), deleterious triple intro-            gressions ("CDMI_3rd"), and P_n for n=1,2,3.        """        SDMI = {} #A dictionary of simple DMIs (B --> A and B --> A)        CDMI = {} #A dictionary of single introgressions that could not be rescued (B --> A)        CDMI_1st = {} #A dictionary of deleterious single introgressions (B --> A)        CDMI_2nd = {} #A dictionary of deleterious double introgressions (B --> A)        CDMI_3rd = {} #A dictionary of deleterious triple introgressions (B --> A)        #Introgress in both directions        single_introg = RNASeq.get_introgression(self.lineageA.seq, self.lineageB.seq, 1)        single_introg_reverse = RNASeq.get_introgression(self.lineageB.seq, self.lineageA.seq, 1)        #The list of diverged loci between the two sequences        loci = RNASeq.get_diverged_alleles(self.lineageA.seq, self.lineageB.seq)[2]        if SDMI_test:            # B --> A            for i in single_introg:                introg = RNASeq(i)                # Check if the single introgression results in an inviable genotype.                if not self.get_fitness(introg):                    first_loci = RNASeq.get_diverged_alleles(self.lineageA.seq, i)[2][0]                    # Check if a second introgression can rescue the first intogression.                    simple = False                    for j in [k for k in loci if k != first_loci]:                        mut = RNASeq.site_directed_mutate(i, j, self.lineageB.seq[j])                        if self.get_fitness(RNASeq(mut)):                            putative_SDMI = tuple(np.sort((first_loci, j)))                            # Check if the incompatibility is deleterious in the other lineage as well.                            if self.test_reciprocity(self.lineageA.seq, self.lineageB.seq, j):                                # Check if the putative DMI involves the new mutation or existed in the previous generation.                                if (first_loci == self.mutated_loci and self.lineageB.seq[first_loci] == self.mutated_allele) or \                                (j == self.mutated_loci and self.lineageA.seq[j] == self.mutated_allele) or putative_SDMI in self.SDMI_past_gen:                                    simple = True                                    # Check that the loci involved aren't both ancestral                                    ancestral_test = [self.lineageB.seq[first_loci] != self.ancestor.seq[first_loci], self.lineageA.seq[j] != self.ancestor.seq[j]]                                    if np.sum(ancestral_test) == 1:                                        SDMI_type = 'AD'                                    else:                                        SDMI_type = 'DD'                                    SDMI[putative_SDMI] = ([(first_loci, j),(self.lineageB.seq[first_loci], self.lineageA.seq[j])], SDMI_type, introg.get_bp_distance(self.ref_seq))                    if not simple:                        # If the single introgression fails to be classified as a simple DMI, count it as a complex DMI.                        CDMI[first_loci] = (self.lineageB.seq[first_loci], introg.get_bp_distance(self.ref_seq))            # A --> B            for i in single_introg_reverse:                introg = RNASeq(i)                # Check if the single introgression results in an inviable genotype.                if not self.get_fitness(introg):                    first_loci = RNASeq.get_diverged_alleles(self.lineageB.seq, i)[2][0]                    # Check if a second introgression can rescue the first intogression.                    for j in [k for k in loci if k != first_loci]:                        mut = RNASeq.site_directed_mutate(i, j, self.lineageA.seq[j])                        if self.get_fitness(RNASeq(mut)):                            putative_SDMI = tuple(np.sort((first_loci, j)))                            # Check if the incompatibility is deleterious in the other lineage as well.                            if self.test_reciprocity(self.lineageB.seq, self.lineageA.seq, j):                                # Check if the putative DMI involves the new mutation or existed in the previous generation.                                if (first_loci == self.mutated_loci and self.lineageA.seq[first_loci] == self.mutated_allele) or \                                (j == self.mutated_loci and self.lineageB.seq[j] == self.mutated_allele) or putative_SDMI in self.SDMI_past_gen:                                    # Check if both are derived or one is ancestral                                    ancestral_test = [self.lineageA.seq[first_loci] != self.ancestor.seq[first_loci], self.lineageB.seq[j] != self.ancestor.seq[j]]                                    if np.sum(ancestral_test) == 1:                                        SDMI_type = 'AD'                                    else:                                        SDMI_type = 'DD'                                    SDMI[putative_SDMI] = ([(first_loci, j),(self.lineageA.seq[first_loci], self.lineageB.seq[j])], SDMI_type, introg.get_bp_distance(self.ref_seq))        # B --> A introgression        single_introg_BA = RNASeq.get_introgression(self.lineageA.seq, self.lineageB.seq, 1)        double_introg_BA = RNASeq.get_introgression(self.lineageA.seq, self.lineageB.seq, 2)        triple_introg_BA = RNASeq.get_introgression(self.lineageA.seq, self.lineageB.seq, 3)        single_introg_num = 0        for i in single_introg_BA:            single_introg_num += 1            g_i = RNASeq(i)            w_i = self.get_fitness(g_i)            if w_i == 0:                pos = RNASeq.get_diverged_alleles(self.lineageA.seq, i)[2][0]                name = tuple([pos])                CDMI_1st[name] = (self.lineageB.seq[pos], self.ref_seq.get_bp_distance(g_i))        double_introg_num = 0        for i in double_introg_BA:            double_introg_num += 1            pos_1st = RNASeq.get_diverged_alleles(self.lineageA.seq, i)[2][0]            pos_2nd = RNASeq.get_diverged_alleles(self.lineageA.seq, i)[2][1]            name = tuple(np.sort([pos_1st, pos_2nd]))            # Check if any of the loci involved are deleterious independently.            order = True            for j in CDMI_1st.keys():                if len(set(name).intersection(set(j))) == 1:                    order = False            if order:                g_i = RNASeq(i)                w_i = self.get_fitness(g_i)                if w_i == 0:                    CDMI_2nd[name] = ((pos_1st, pos_2nd),(self.lineageB.seq[pos_1st], self.lineageB.seq[pos_2nd]), self.ref_seq.get_bp_distance(g_i))        triple_introg_num = 0        for i in triple_introg_BA:            triple_introg_num += 1            pos_1st = RNASeq.get_diverged_alleles(self.lineageA.seq, i)[2][0]            pos_2nd = RNASeq.get_diverged_alleles(self.lineageA.seq, i)[2][1]            pos_3rd = RNASeq.get_diverged_alleles(self.lineageA.seq, i)[2][2]            name = tuple(np.sort([pos_1st, pos_2nd, pos_3rd]))            # Check if any of the loci involved are deleterious independently.            order = True            for j in CDMI_2nd.keys():                if len(set(name).intersection(set(j))) == 2:                    order = False            for l in CDMI_1st.keys():                if len(set(name).intersection(set(l))) == 1:                    order = False            if order:                g_i = RNASeq(i)                w_i = self.get_fitness(g_i)                if w_i == 0:                    CDMI_3rd[name] = ((pos_1st, pos_2nd, pos_3rd),(self.lineageB.seq[pos_1st], self.lineageB.seq[pos_2nd], self.lineageB.seq[pos_3rd]), self.ref_seq.get_bp_distance(g_i))        if not single_introg_num:            p1 = 0        else:            p1 = len(CDMI_1st)/float(single_introg_num)        if not double_introg_num:            p2 = 0        else:            p2 = len(CDMI_2nd)/float(double_introg_num)        if not triple_introg_num:            p3 = 0        else:            p3 = len(CDMI_3rd)/float(triple_introg_num)        return {'SDMI' : SDMI,                'CDMI': CDMI,                'CDMI_1st': CDMI_1st,                'CDMI_2nd': CDMI_2nd,                'CDMI_3rd': CDMI_3rd,                'p1': p1,                'p2': p2,                'p3': p3}    def get_RI(self):        """Calculate the level of reproductive isolation and relevant measurements.        Returns        -------        name : dictionary            A dictionary of results relevant to RI calculation.        """        single_cross_recs = {}        RI = []        w_rec_series = []        mfe_rec_series = []        count = 0        for i, j in zip(self.linA, self.linB):            recs = RNASeq.recombine(i.seq, j.seq)            recombinants = [RNASeq(l) for l in recs]            single_cross_recs[count] = recs            w_rec = [self.get_fitness(m) for m in recombinants]            RI.append(1. - np.sum(w_rec) / float(len(w_rec)))            mfe_rec_series.append(np.mean([n.mfe for n in recombinants]))            count += 1        return {'RI': RI,                'mfe_rec_series': mfe_rec_series,                'single_cross_recs': single_cross_recs}    def burnin(self, t):        """Allow the starting sequence to undergoe t point mutations (a locus can undergoe multiple subs.)        Parameters        ----------        t : int            The length of the burnin period.        """        count = 0        while count < t:            fix = 0            while not fix:                mut = deepcopy(self.ancestor)                mut = RNASeq(RNASeq.mutate(mut.seq))                fix = self.get_fitness(mut)            self.ancestor = mut            count += 1        self.lineageA = deepcopy(self.ancestor)        self.lineageB = deepcopy(self.ancestor)    def substitute(self, pop):        """Introduce point mutations into one of the lineages.        Parameters        ----------        pop : int            An integer signifying one of the lineages.        Raises        ------        ValueError,            pop must be either 1 or 2.        """        if pop == 1:            fix = 0            while not fix:                next_gen = deepcopy(self.lineageA)                next_gen.diverge(self.lineageB)                fix = self.get_fitness(next_gen)            self.mutated_loci = RNASeq.get_diverged_alleles(next_gen.seq, self.lineageA.seq)[2][0]            self.lineageA = next_gen            self.mutated_allele = self.lineageA.seq[self.mutated_loci]            self.mutated_line = 'A'        elif pop == 2:            fix = 0            while not fix:                next_gen = deepcopy(self.lineageB)                next_gen.diverge(self.lineageA)                fix = self.get_fitness(next_gen)            self.mutated_loci = RNASeq.get_diverged_alleles(next_gen.seq, self.lineageB.seq)[2][0]            self.lineageB = next_gen            self.mutated_allele = self.lineageB.seq[self.mutated_loci]            self.mutated_line = 'B'        else:            raise ValueError, 'Must be either 1 or 2.'    def substitute_with_multi(self, pop):        """Introduce point mutations into one of the lineages while allowing any locus to undergoe multiple subs.        Parameters        ----------        pop : int            An integer signifying one of the lineages.        Raises        ------        ValueError,            pop must be either 1 or 2.        """        if pop == 1:            fix = 0            while not fix:                mut = deepcopy(self.lineageA)                mut = RNASeq(RNASeq.mutate(mut.seq))                fix = self.get_fitness(mut)            self.mutated_loci = RNASeq.get_diverged_alleles(mut.seq, self.lineageA.seq)[2][0]            self.lineageA = mut        elif pop == 2:            fix = 0            while not fix:                mut = deepcopy(self.lineageB)                mut = RNASeq(RNASeq.mutate(mut.seq))                fix = self.get_fitness(mut)            self.mutated_loci = RNASeq.get_diverged_alleles(mut.seq, self.lineageB.seq)[2][0]            self.lineageB = mut        else:            raise ValueError, 'Must be either 1 or 2.'    def evolve_with_multi_sub(self, divergence=40, burnin=200, verbose=False):        """Allow the two lineages to diverge while allowing any locus to undergoe multiple subs.        Parameters        ----------        divergence : int, optional            The final hamming distance between the two lineages.        burnin : int, optional            The length of the burnin period.        verbose : bool, optional            print the hamming distance whenever it increases by one.        """        self.init_history()        self.burnin(burnin)        myIterator = cycle(range(2))        d = 0        count = 0        while d < divergence:            self.substitute_with_multi(pop=myIterator.next() + 1)            count += 1            if self.lineageA.hamdist(self.lineageB) == d + 1:                self.add_to_history(SDMI_test=False)                d += 1                if verbose:                    print count,    def evolve(self, divergence=40, burnin=200, verbose=False):        """Allow the two lineages to diverge.        Parameters        ----------        divergence : int, optional            The total number of mutations accumulated in both lineages.        burnin : int, optional            The length of the burnin period.        verbose : bool, optional            print the hamming distance after each sub.        """        self.init_history()        self.burnin(burnin)        myIterator = cycle(range(2))        for i in range(divergence):            self.substitute(pop=myIterator.next() + 1)            self.add_to_history()            if verbose:                print i + 1,if __name__ == "__main__":    import doctest    doctest.testmod()